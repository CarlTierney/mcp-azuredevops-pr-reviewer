"""Comprehensive package vulnerability analyzer that checks entire codebase"""

import os
import json
import xml.etree.ElementTree as ET
import logging
import subprocess
import asyncio
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import re

logger = logging.getLogger(__name__)


@dataclass
class Package:
    """Represents a package dependency"""
    name: str
    version: str
    file_path: str
    package_type: str  # npm, nuget, pip, maven, etc.
    is_vulnerable: bool = False
    vulnerabilities: List[Dict] = None
    latest_version: Optional[str] = None
    
    def __post_init__(self):
        if self.vulnerabilities is None:
            self.vulnerabilities = []


@dataclass
class VulnerabilityReport:
    """Complete vulnerability report for a codebase"""
    total_packages: int
    vulnerable_packages: int
    critical_vulnerabilities: int
    high_vulnerabilities: int
    medium_vulnerabilities: int
    low_vulnerabilities: int
    outdated_packages: int
    packages: List[Package]
    scan_time: datetime
    recommendations: List[str]


class PackageVulnerabilityAnalyzer:
    """Analyzes entire codebase for package vulnerabilities"""
    
    def __init__(self, working_directory: Path):
        self.working_dir = Path(working_directory)
        self.packages: List[Package] = []
        self.vulnerability_db = self._load_vulnerability_database()
        
    def _load_vulnerability_database(self) -> Dict:
        """Load known vulnerabilities database"""
        # In production, this would connect to:
        # - GitHub Advisory Database
        # - NVD (National Vulnerability Database)
        # - Snyk vulnerability DB
        # - npm audit
        # - OWASP dependency check
        
        # Sample vulnerability data for demonstration
        return {
            "npm": {
                "lodash": {
                    "vulnerable_versions": ["< 4.17.21"],
                    "cve": "CVE-2021-23337",
                    "severity": "high",
                    "description": "Command Injection vulnerability"
                },
                "minimist": {
                    "vulnerable_versions": ["< 1.2.6"],
                    "cve": "CVE-2021-44906",
                    "severity": "critical",
                    "description": "Prototype Pollution vulnerability"
                },
                "axios": {
                    "vulnerable_versions": ["< 0.21.2"],
                    "cve": "CVE-2021-3749",
                    "severity": "high",
                    "description": "Regular Expression Denial of Service"
                }
            },
            "nuget": {
                "Newtonsoft.Json": {
                    "vulnerable_versions": ["< 13.0.1"],
                    "cve": "CVE-2021-42219",
                    "severity": "high",
                    "description": "Denial of Service vulnerability"
                },
                "System.Text.Encodings.Web": {
                    "vulnerable_versions": ["< 4.7.2", "5.0.0"],
                    "cve": "CVE-2021-26701",
                    "severity": "critical",
                    "description": "Remote Code Execution vulnerability"
                }
            },
            "pip": {
                "django": {
                    "vulnerable_versions": ["< 3.2.13", "< 4.0.4"],
                    "cve": "CVE-2022-28346",
                    "severity": "high",
                    "description": "SQL Injection vulnerability"
                },
                "pillow": {
                    "vulnerable_versions": ["< 9.0.1"],
                    "cve": "CVE-2022-24303",
                    "severity": "critical",
                    "description": "Buffer overflow vulnerability"
                }
            }
        }
    
    async def analyze_repository(self, repo_path: Path) -> VulnerabilityReport:
        """Analyze entire repository for package vulnerabilities
        
        This method:
        1. Searches ALL folders for package files
        2. Extracts package information from each file
        3. Checks for known vulnerabilities
        4. Verifies package versions
        5. Generates comprehensive report
        """
        
        print(f"\n{'='*60}")
        print(f"COMPREHENSIVE PACKAGE VULNERABILITY ANALYSIS")
        print(f"{'='*60}")
        print(f"Repository: {repo_path}")
        print(f"Scanning all directories for package files...")
        print()
        
        # Find all package files in the repository
        package_files = self._find_all_package_files(repo_path)
        
        print(f"Found {len(package_files)} package files:")
        for file_type, files in package_files.items():
            if files:
                print(f"  {file_type}: {len(files)} file(s)")
                for f in files[:3]:  # Show first 3
                    print(f"    - {f.relative_to(repo_path)}")
                if len(files) > 3:
                    print(f"    ... and {len(files)-3} more")
        print()
        
        # Analyze each package file
        for file_type, files in package_files.items():
            for file_path in files:
                print(f"Analyzing: {file_path.relative_to(repo_path)}")
                
                if file_type == "npm":
                    await self._analyze_npm_packages(file_path)
                elif file_type == "nuget":
                    await self._analyze_nuget_packages(file_path)
                elif file_type == "pip":
                    await self._analyze_pip_packages(file_path)
                elif file_type == "maven":
                    await self._analyze_maven_packages(file_path)
                elif file_type == "composer":
                    await self._analyze_composer_packages(file_path)
        
        # Check for vulnerabilities
        print("\nChecking for vulnerabilities...")
        vulnerable_count = 0
        critical_count = 0
        high_count = 0
        medium_count = 0
        low_count = 0
        
        for package in self.packages:
            vulns = self._check_vulnerabilities(package)
            if vulns:
                package.is_vulnerable = True
                package.vulnerabilities = vulns
                vulnerable_count += 1
                
                for vuln in vulns:
                    severity = vuln.get('severity', 'unknown')
                    if severity == 'critical':
                        critical_count += 1
                    elif severity == 'high':
                        high_count += 1
                    elif severity == 'medium':
                        medium_count += 1
                    elif severity == 'low':
                        low_count += 1
                
                print(f"  [VULNERABLE]: {package.name}@{package.version}")
                for vuln in vulns:
                    print(f"    - {vuln['cve']}: {vuln['description']} (Severity: {vuln['severity'].upper()})")
        
        # Check for outdated packages
        print("\nChecking for outdated packages...")
        outdated_count = await self._check_outdated_packages()
        
        # Generate recommendations
        recommendations = self._generate_recommendations(
            vulnerable_count, critical_count, high_count, outdated_count
        )
        
        # Create report
        report = VulnerabilityReport(
            total_packages=len(self.packages),
            vulnerable_packages=vulnerable_count,
            critical_vulnerabilities=critical_count,
            high_vulnerabilities=high_count,
            medium_vulnerabilities=medium_count,
            low_vulnerabilities=low_count,
            outdated_packages=outdated_count,
            packages=self.packages,
            scan_time=datetime.now(),
            recommendations=recommendations
        )
        
        # Print summary
        self._print_report_summary(report)
        
        return report
    
    def _find_all_package_files(self, repo_path: Path) -> Dict[str, List[Path]]:
        """Find all package files in the repository"""
        
        package_patterns = {
            "npm": ["package.json", "package-lock.json", "yarn.lock"],
            "nuget": ["*.csproj", "*.fsproj", "*.vbproj", "packages.config", "*.props"],
            "pip": ["requirements.txt", "requirements*.txt", "Pipfile", "Pipfile.lock", "setup.py", "pyproject.toml"],
            "maven": ["pom.xml"],
            "composer": ["composer.json", "composer.lock"]
        }
        
        found_files = {
            "npm": [],
            "nuget": [],
            "pip": [],
            "maven": [],
            "composer": []
        }
        
        # Walk through all directories
        for root, dirs, files in os.walk(repo_path):
            # Skip hidden directories and common non-code directories
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', 'vendor', 'bin', 'obj']]
            
            root_path = Path(root)
            
            for file in files:
                file_lower = file.lower()
                file_path = root_path / file
                
                # Check each package type
                for pkg_type, patterns in package_patterns.items():
                    for pattern in patterns:
                        if pattern.startswith('*'):
                            if file_lower.endswith(pattern[1:]):
                                found_files[pkg_type].append(file_path)
                                break
                        elif pattern.endswith('*'):
                            if file_lower.startswith(pattern[:-1]):
                                found_files[pkg_type].append(file_path)
                                break
                        elif file_lower == pattern.lower():
                            found_files[pkg_type].append(file_path)
                            break
        
        return found_files
    
    async def _analyze_npm_packages(self, package_file: Path):
        """Analyze npm package.json or lock files"""
        try:
            with open(package_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Get dependencies
            deps = {}
            if 'dependencies' in data:
                deps.update(data['dependencies'])
            if 'devDependencies' in data:
                deps.update(data['devDependencies'])
            
            for name, version in deps.items():
                # Clean version string
                clean_version = self._clean_version(version)
                
                package = Package(
                    name=name,
                    version=clean_version,
                    file_path=str(package_file),
                    package_type='npm'
                )
                self.packages.append(package)
                
        except Exception as e:
            logger.error(f"Error analyzing npm packages in {package_file}: {e}")
    
    async def _analyze_nuget_packages(self, project_file: Path):
        """Analyze NuGet packages from .csproj or packages.config"""
        try:
            tree = ET.parse(project_file)
            root = tree.getroot()
            
            # Handle .csproj files (new format)
            if project_file.suffix == '.csproj':
                for item in root.findall('.//PackageReference'):
                    name = item.get('Include')
                    version = item.get('Version', 'unknown')
                    
                    if name:
                        package = Package(
                            name=name,
                            version=version,
                            file_path=str(project_file),
                            package_type='nuget'
                        )
                        self.packages.append(package)
            
            # Handle packages.config
            elif project_file.name == 'packages.config':
                for package_elem in root.findall('.//package'):
                    name = package_elem.get('id')
                    version = package_elem.get('version', 'unknown')
                    
                    if name:
                        package = Package(
                            name=name,
                            version=version,
                            file_path=str(project_file),
                            package_type='nuget'
                        )
                        self.packages.append(package)
                        
        except Exception as e:
            logger.error(f"Error analyzing NuGet packages in {project_file}: {e}")
    
    async def _analyze_pip_packages(self, requirements_file: Path):
        """Analyze pip requirements files"""
        try:
            with open(requirements_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    # Parse package and version
                    match = re.match(r'^([a-zA-Z0-9\-_]+)\s*([><=~!]+)\s*(.+)$', line)
                    if match:
                        name = match.group(1)
                        version = match.group(3)
                    else:
                        # Package without version
                        name = line.split('[')[0].strip()
                        version = 'unspecified'
                    
                    package = Package(
                        name=name,
                        version=version,
                        file_path=str(requirements_file),
                        package_type='pip'
                    )
                    self.packages.append(package)
                    
        except Exception as e:
            logger.error(f"Error analyzing pip packages in {requirements_file}: {e}")
    
    async def _analyze_maven_packages(self, pom_file: Path):
        """Analyze Maven pom.xml files"""
        try:
            tree = ET.parse(pom_file)
            root = tree.getroot()
            
            # Handle namespace
            ns = {'maven': 'http://maven.apache.org/POM/4.0.0'}
            
            for dep in root.findall('.//maven:dependency', ns) or root.findall('.//dependency'):
                group_id = dep.find('groupId').text if dep.find('groupId') is not None else 'unknown'
                artifact_id = dep.find('artifactId').text if dep.find('artifactId') is not None else 'unknown'
                version = dep.find('version').text if dep.find('version') is not None else 'unspecified'
                
                name = f"{group_id}:{artifact_id}"
                
                package = Package(
                    name=name,
                    version=version,
                    file_path=str(pom_file),
                    package_type='maven'
                )
                self.packages.append(package)
                
        except Exception as e:
            logger.error(f"Error analyzing Maven packages in {pom_file}: {e}")
    
    async def _analyze_composer_packages(self, composer_file: Path):
        """Analyze PHP Composer files"""
        try:
            with open(composer_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Get requirements
            reqs = {}
            if 'require' in data:
                reqs.update(data['require'])
            if 'require-dev' in data:
                reqs.update(data['require-dev'])
            
            for name, version in reqs.items():
                package = Package(
                    name=name,
                    version=version,
                    file_path=str(composer_file),
                    package_type='composer'
                )
                self.packages.append(package)
                
        except Exception as e:
            logger.error(f"Error analyzing Composer packages in {composer_file}: {e}")
    
    def _check_vulnerabilities(self, package: Package) -> List[Dict]:
        """Check if a package has known vulnerabilities"""
        vulnerabilities = []
        
        # Check in vulnerability database
        if package.package_type in self.vulnerability_db:
            type_db = self.vulnerability_db[package.package_type]
            
            if package.name in type_db:
                vuln_info = type_db[package.name]
                
                # Check if current version is vulnerable
                for vuln_version in vuln_info['vulnerable_versions']:
                    if self._is_version_vulnerable(package.version, vuln_version):
                        vulnerabilities.append({
                            'cve': vuln_info['cve'],
                            'severity': vuln_info['severity'],
                            'description': vuln_info['description'],
                            'affected_versions': vuln_version
                        })
        
        return vulnerabilities
    
    def _is_version_vulnerable(self, current_version: str, vulnerable_spec: str) -> bool:
        """Check if a version matches vulnerability specification"""
        
        # Simple version comparison (in production, use proper semver library)
        if vulnerable_spec.startswith('<'):
            # Version is vulnerable if less than specified
            target = vulnerable_spec[1:].strip()
            return self._compare_versions(current_version, target) < 0
        elif vulnerable_spec.startswith('<='):
            target = vulnerable_spec[2:].strip()
            return self._compare_versions(current_version, target) <= 0
        elif vulnerable_spec == current_version:
            return True
        
        return False
    
    def _compare_versions(self, v1: str, v2: str) -> int:
        """Simple version comparison"""
        # This is a simplified version comparison
        # In production, use proper semver comparison
        
        try:
            v1_parts = [int(x) for x in v1.split('.')]
            v2_parts = [int(x) for x in v2.split('.')]
            
            for i in range(max(len(v1_parts), len(v2_parts))):
                p1 = v1_parts[i] if i < len(v1_parts) else 0
                p2 = v2_parts[i] if i < len(v2_parts) else 0
                
                if p1 < p2:
                    return -1
                elif p1 > p2:
                    return 1
            
            return 0
        except:
            # If comparison fails, assume not vulnerable
            return 1
    
    async def _check_outdated_packages(self) -> int:
        """Check for outdated packages"""
        
        outdated_count = 0
        
        # In production, this would:
        # - Query npm registry for latest versions
        # - Query NuGet for latest versions
        # - Query PyPI for latest versions
        # - Compare with current versions
        
        # For now, we'll simulate by checking some known packages
        latest_versions = {
            "npm": {
                "react": "18.2.0",
                "vue": "3.3.4",
                "angular": "16.2.0",
                "lodash": "4.17.21"
            },
            "nuget": {
                "Newtonsoft.Json": "13.0.3",
                "Microsoft.EntityFrameworkCore": "7.0.10"
            },
            "pip": {
                "django": "4.2.5",
                "flask": "2.3.3",
                "requests": "2.31.0"
            }
        }
        
        for package in self.packages:
            if package.package_type in latest_versions:
                type_latest = latest_versions[package.package_type]
                if package.name in type_latest:
                    latest = type_latest[package.name]
                    if self._compare_versions(package.version, latest) < 0:
                        package.latest_version = latest
                        outdated_count += 1
                        print(f"  [OUTDATED]: {package.name}@{package.version} (latest: {latest})")
        
        return outdated_count
    
    def _clean_version(self, version: str) -> str:
        """Clean version string"""
        # Remove common prefixes
        version = version.lstrip('^~>=<!')
        # Remove any ranges
        version = version.split(',')[0]
        version = version.split('||')[0]
        return version.strip()
    
    def _generate_recommendations(self, vulnerable: int, critical: int, high: int, outdated: int) -> List[str]:
        """Generate security recommendations"""
        
        recommendations = []
        
        if critical > 0:
            recommendations.append(f"[CRITICAL]: Fix {critical} critical vulnerability(ies) immediately")
            recommendations.append("   These could lead to remote code execution or data breach")
        
        if high > 0:
            recommendations.append(f"[HIGH PRIORITY]: Address {high} high severity vulnerability(ies)")
            recommendations.append("   These pose significant security risks")
        
        if vulnerable > 0:
            recommendations.append(f"[SECURITY]: Update {vulnerable} vulnerable package(s) to secure versions")
            recommendations.append("   Run 'npm audit fix' for npm packages")
            recommendations.append("   Update .csproj references for NuGet packages")
            recommendations.append("   Use pip-audit for Python packages")
        
        if outdated > 5:
            recommendations.append(f"[UPDATE]: Consider updating {outdated} outdated packages")
            recommendations.append("   Staying current reduces security risks")
        
        recommendations.append("[RECOMMENDATION]: Implement automated dependency scanning in CI/CD")
        recommendations.append("[RECOMMENDATION]: Regular security audits should be performed")
        recommendations.append("[RECOMMENDATION]: Keep dependencies up-to-date with latest patches")
        
        return recommendations
    
    def _print_report_summary(self, report: VulnerabilityReport):
        """Print a summary of the vulnerability report"""
        
        print(f"\n{'='*60}")
        print(f"VULNERABILITY REPORT SUMMARY")
        print(f"{'='*60}")
        print(f"Scan completed: {report.scan_time.strftime('%Y-%m-%d %H:%M:%S')}")
        print()
        
        print(f"[STATISTICS]:")
        print(f"  Total packages analyzed: {report.total_packages}")
        print(f"  Vulnerable packages: {report.vulnerable_packages}")
        print(f"  Outdated packages: {report.outdated_packages}")
        print()
        
        print(f"[VULNERABILITIES BY SEVERITY]:")
        print(f"  Critical: {report.critical_vulnerabilities}")
        print(f"  High: {report.high_vulnerabilities}")
        print(f"  Medium: {report.medium_vulnerabilities}")
        print(f"  Low: {report.low_vulnerabilities}")
        print()
        
        if report.vulnerable_packages > 0:
            print(f"[VULNERABLE PACKAGES]:")
            for pkg in report.packages:
                if pkg.is_vulnerable:
                    print(f"  - {pkg.name}@{pkg.version} ({pkg.package_type})")
                    for vuln in pkg.vulnerabilities[:2]:  # Show first 2
                        print(f"    • {vuln['cve']}: {vuln['severity'].upper()}")
            print()
        
        print(f"[RECOMMENDATIONS]:")
        for rec in report.recommendations:
            print(f"  {rec}")
        print()
        
        # Overall risk assessment
        if report.critical_vulnerabilities > 0:
            print(f"[RISK LEVEL]: CRITICAL - Immediate action required!")
        elif report.high_vulnerabilities > 0:
            print(f"[RISK LEVEL]: HIGH - Address vulnerabilities soon")
        elif report.vulnerable_packages > 0:
            print(f"[RISK LEVEL]: MEDIUM - Plan updates")
        else:
            print(f"[RISK LEVEL]: LOW - No known vulnerabilities")


async def analyze_pr_packages(repo_path: Path) -> VulnerabilityReport:
    """Main function to analyze packages in a PR"""
    
    analyzer = PackageVulnerabilityAnalyzer(repo_path)
    report = await analyzer.analyze_repository(repo_path)
    
    return report


if __name__ == "__main__":
    print("PACKAGE VULNERABILITY ANALYZER")
    print("Comprehensive analysis of all packages in codebase")
    print()
    
    # Example usage
    async def test_analyzer():
        # Test with current directory or specify a path
        test_path = Path(".")  # or Path("d:/dev/prreview/Zinnia")
        
        if test_path.exists():
            report = await analyze_pr_packages(test_path)
            
            # The report can be used to:
            # 1. Block PRs with critical vulnerabilities
            # 2. Warn about high/medium vulnerabilities
            # 3. Suggest package updates
            # 4. Generate security reports
            
            if report.critical_vulnerabilities > 0:
                print("\n❌ PR SHOULD BE BLOCKED - Critical vulnerabilities found!")
            elif report.high_vulnerabilities > 0:
                print("\n⚠️ PR NEEDS REVIEW - High severity vulnerabilities found")
            else:
                print("\n✅ Package security check passed")
        else:
            print(f"Path {test_path} does not exist")
    
    # Run the test
    asyncio.run(test_analyzer())